"""Generates the Micropython shims for the Resonite API."""

import enum
import json
import sys

HEADER_PREAMBLE = """
#ifndef __DERGWASM_MICROPYTHON_USERCMODULE_RESONITE_RESONITE_API_H__
#define __DERGWASM_MICROPYTHON_USERCMODULE_RESONITE_RESONITE_API_H__

#include "py/obj.h"
#include "py/runtime.h"

// Micropython shims for the Resonite API.
// Autogenerated by generate_api.py. DO NOT EDIT.

"""

HEADER_POSTAMBLE = """
#endif // __DERGWASM_MICROPYTHON_USERCMODULE_RESONITE_RESONITE_API_H__
"""

IMPL_PREAMBLE = """
#include "mp_resonite_api.h"

#include <stdbool.h>
#include <stdint.h>
#include <string.h>

#include "py/obj.h"
#include "py/runtime.h"
#include "resonite_api.h"
#include "mp_resonite_utils.h"

// Micropython shims for the Resonite API.
// Autogenerated by generate_api.py. DO NOT EDIT.

"""


@enum.unique
class ValueType(enum.IntEnum):
    I32 = 0x7F
    I64 = 0x7E
    F32 = 0x7D
    F64 = 0x7C
    V128 = 0x7B
    FUNCREF = 0x70
    EXTERNREF = 0x6F


class GenericType:
    base_type: str
    type_params: list["GenericType"]

    def __init__(self, base_type: str, type_params: list["GenericType"] | None = None):
        self.base_type = base_type
        self.type_params = type_params if type_params is not None else []

    @staticmethod
    def parse_generic_type(s: str) -> "GenericType":
        # Helper function to split the string by commas, considering nested generics
        def split_type_params(s: str) -> list[str]:
            params: list[str] = []
            bracket_level = 0
            current = ""
            for char in s:
                if char == "," and bracket_level == 0:
                    params.append(current)
                    current = ""
                else:
                    if char == "<":
                        bracket_level += 1
                    elif char == ">":
                        bracket_level -= 1
                    current += char
            if current:
                params.append(current)
            return params

        # Base case: no type parameters
        if "<" not in s:
            return GenericType(s)

        # Recursive case: parse type parameters
        base_type, rest = s.split("<", 1)
        type_params_str = rest[:-1]  # Remove the closing '>'
        type_params = [
            GenericType.parse_generic_type(tp.strip())
            for tp in split_type_params(type_params_str)
        ]
        return GenericType(base_type, type_params)

    def __repr__(self) -> str:
        if not self.type_params:
            return self.base_type
        return f"{self.base_type}:({', '.join(map(str, self.type_params))})"


PY_TO_WASM: dict[ValueType, str] = {
    ValueType.I32: "(int32_t)mp_obj_get_int",
    ValueType.I64: "mp_obj_int_get_int64_checked",
    ValueType.F32: "(float)mp_obj_get_float",
    ValueType.F64: "(double)mp_obj_get_float",
}

WASM_TO_PY: dict[ValueType, str] = {
    ValueType.I32: "mp_obj_new_int_from_ll",
    ValueType.I64: "mp_obj_new_int_from_ll",
    ValueType.F32: "mp_obj_new_float",
    ValueType.F64: "mp_obj_new_float",
}


class Main:
    def __init__(self) -> None:
        pass

    @staticmethod
    def py_to_wasm(value_type: ValueType, cc_type: GenericType, val: str) -> str:
        """Converts a Python value to a Dergwasm value, for arguments."""
        cc_type_str = str(cc_type)
        if cc_type_str == "int":
            return f"(int32_t)mp_obj_get_int({val})"
        if cc_type_str == "uint":
            return f"(uint32_t)mp_obj_get_int({val})"
        if cc_type_str == "long":
            return f"mp_obj_int_get_int64_checked({val})"
        if cc_type_str == "ulong":
            return f"mp_obj_int_get_uint64_checked({val})"
        if cc_type_str == "float":
            return f"(float)mp_obj_get_float({val})"
        if cc_type_str == "double":
            return f"(double)mp_obj_get_float({val})"
        if cc_type_str == "bool":
            return f"mp_obj_is_true({val}) ? 1 : 0"
        if cc_type_str.startswith("WasmRefID"):
            return f"mp_obj_int_get_uint64_checked({val})"
        if cc_type_str.startswith("Ptr"):
            return f"(int32_t)mp_obj_get_int({val})"
        if cc_type_str == "NullTerminatedString":
            return f"mp_obj_str_get_str({val})"
        return f"{PY_TO_WASM[value_type]}({val})"

    @staticmethod
    def wasm_to_py(value_type: ValueType, cc_type: GenericType, val: str) -> str:
        """Converts a Dergwasm value to a Python value, for return values."""
        cc_type_str = str(cc_type)
        if cc_type_str in ["int", "uint", "long", "ulong"]:
            return f"mp_obj_new_int_from_ll({val})"
        if cc_type_str in ["float", "double"]:
            return f"mp_obj_new_float({val})"
        if cc_type_str == "bool":
            return f"mp_obj_new_bool({val})"
        if cc_type_str.startswith("WasmRefID"):
            return f"mp_obj_new_int_from_ll({val})"
        if cc_type_str.startswith("Ptr"):
            return f"mp_obj_new_int_from_ll({val})"
        if cc_type_str == "NullTerminatedString":
            return f"mp_obj_new_null_terminated_str({val})"
        return f"{WASM_TO_PY[value_type]}({val})"

    def generate_header(self) -> None:
        with open("resonite_api.json", "r", encoding="UTF8") as f:
            data = json.load(f)

        with open(
            "micropython/usercmodule/resonite/mp_resonite_api.h", "w", encoding="UTF8"
        ) as f:
            f.write(HEADER_PREAMBLE)
            for item in data:
                f.write(f'extern mp_obj_t resonite__{item["Name"]}(')
                params = [f'mp_obj_t {param["Name"]}' for param in item["Parameters"]]
                f.write(", ".join(params))
                f.write(");\n")
            f.write(HEADER_POSTAMBLE)

        with open(
            "micropython/usercmodule/resonite/mp_resonite_api.c", "w", encoding="UTF8"
        ) as f:
            f.write(IMPL_PREAMBLE)
            for item in data:
                params = [f'mp_obj_t {param["Name"]}' for param in item["Parameters"]]
                f.write(f'mp_obj_t resonite__{item["Name"]}({", ".join(params)}) {{\n')

                call_params: list[str] = []
                for param in item["Parameters"]:
                    value_type = ValueType(param["Type"])
                    generic_type = GenericType.parse_generic_type(param["CSType"])
                    converted = self.py_to_wasm(value_type, generic_type, param["Name"])
                    call_params.append(f"\n    {converted}")
                call = f'{item["Name"]}({", ".join(call_params)})'

                if len(item["Returns"]) == 0:
                    f.write(f"  {call};\n")
                    f.write("  return mp_const_none;\n")
                else:
                    ret_type = ValueType(item["Returns"][0]["Type"])
                    ret_generic_type = GenericType.parse_generic_type(
                        item["Returns"][0]["CSType"]
                    )
                    converted = self.wasm_to_py(ret_type, ret_generic_type, call)
                    f.write(f"  return {converted};\n")

                f.write("}\n\n")

    def main(self) -> int:
        self.generate_header()
        return 0


if __name__ == "__main__":
    sys.exit(Main().main())
