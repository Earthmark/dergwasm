"""Generates the Micropython shims for the Resonite API."""

import enum
import json
import pathlib

HEADER_PREAMBLE = """
#ifndef __DERGWASM_MICROPYTHON_USERCMODULE_RESONITE_RESONITE_API_H__
#define __DERGWASM_MICROPYTHON_USERCMODULE_RESONITE_RESONITE_API_H__

#include "py/obj.h"
#include "py/runtime.h"

// Micropython shims for the Resonite API.
// Autogenerated by generate_api.py. DO NOT EDIT.

"""

HEADER_POSTAMBLE = """
#endif // __DERGWASM_MICROPYTHON_USERCMODULE_RESONITE_RESONITE_API_H__
"""

IMPL_PREAMBLE = """
#include "mp_resonite_api.h"

#include <stdbool.h>
#include <stdint.h>
#include <string.h>

#include "py/obj.h"
#include "py/runtime.h"
#include "resonite_api.h"
#include "mp_resonite_utils.h"

// Micropython shims for the Resonite API.
// Autogenerated by generate_api.py. DO NOT EDIT.

"""


def output_dir() -> pathlib.Path:
    """Gets the path to the directory where the generated files should be placed."""
    return pathlib.Path(__file__).parent.resolve()


@enum.unique
class ValueType(enum.IntEnum):
    I32 = 0x7F
    I64 = 0x7E
    F32 = 0x7D
    F64 = 0x7C
    V128 = 0x7B
    FUNCREF = 0x70
    EXTERNREF = 0x6F


class GenericType:
    base_type: str
    type_params: list["GenericType"]

    def __init__(self, base_type: str, type_params: list["GenericType"] | None = None):
        self.base_type = base_type
        self.type_params = type_params if type_params is not None else []

    @staticmethod
    def parse_generic_type(s: str) -> "GenericType":
        # Helper function to split the string by commas, considering nested generics
        def split_type_params(s: str) -> list[str]:
            params: list[str] = []
            bracket_level = 0
            current = ""
            for char in s:
                if char == "," and bracket_level == 0:
                    params.append(current)
                    current = ""
                else:
                    if char == "<":
                        bracket_level += 1
                    elif char == ">":
                        bracket_level -= 1
                    current += char
            if current:
                params.append(current)
            return params

        # Base case: no type parameters
        if "<" not in s:
            return GenericType(s)

        # Recursive case: parse type parameters
        base_type, rest = s.split("<", 1)
        type_params_str = rest[:-1]  # Remove the closing '>'
        type_params = [
            GenericType.parse_generic_type(tp.strip())
            for tp in split_type_params(type_params_str)
        ]
        return GenericType(base_type, type_params)

    def __repr__(self) -> str:
        if not self.type_params:
            return self.base_type
        return f"{self.base_type}:({', '.join(map(str, self.type_params))})"


PY_TO_WASM: dict[ValueType, str] = {
    ValueType.I32: "(int32_t)mp_obj_get_int",
    ValueType.I64: "mp_obj_int_get_int64_checked",
    ValueType.F32: "(float)mp_obj_get_float",
    ValueType.F64: "(double)mp_obj_get_float",
}

WASM_TO_PY: dict[ValueType, str] = {
    ValueType.I32: "mp_obj_new_int_from_ll",
    ValueType.I64: "mp_obj_new_int_from_ll",
    ValueType.F32: "mp_obj_new_float",
    ValueType.F64: "mp_obj_new_float",
}

# If an out parameter has one of these types, it should be freed after
# "absorbing" it into a Python object.
CC_TYPES_TO_FREE: list[str] = ["WasmArray"]


class Main:
    """The main class for the Micropython API generator."""

    @staticmethod
    def wasm_to_c(cc_type: GenericType) -> str:
        """Converts a Dergwasm type to a C type."""
        cc_type_str = cc_type.base_type
        if cc_type_str == "int":
            return "int32_t"
        if cc_type_str == "uint":
            return "uint32_t"
        if cc_type_str == "long":
            return "int64_t"
        if cc_type_str == "ulong":
            return "uint64_t"
        if cc_type_str == "float":
            return "float"
        if cc_type_str == "double":
            return "double"
        if cc_type_str == "bool":
            return "bool"
        if cc_type_str == "WasmRefID":
            return "resonite_refid_t"
        if cc_type_str == "Ptr":
            return Main.wasm_to_c(cc_type.type_params[0]) + "*"
        if cc_type_str == "WasmArray":
            return Main.wasm_to_c(cc_type.type_params[0]) + "*"
        if cc_type_str == "NullTerminatedString":
            return "char *"
        if cc_type_str == "ResoniteError":
            return "resonite_error_t"
        if cc_type_str == "ResoniteType":
            return "resonite_type_t"
        raise ValueError(f"Unknown type: {cc_type_str}")

    @staticmethod
    def py_to_wasm(value_type: ValueType, cc_type: GenericType, val: str) -> str:
        """Converts a Python value to a Dergwasm value, for arguments."""
        cc_type_str = str(cc_type)
        if cc_type_str == "int":
            return f"(int32_t)mp_obj_get_int({val})"
        if cc_type_str == "uint":
            return f"(uint32_t)mp_obj_get_int({val})"
        if cc_type_str == "long":
            return f"mp_obj_int_get_int64_checked({val})"
        if cc_type_str == "ulong":
            return f"mp_obj_int_get_uint64_checked({val})"
        if cc_type_str == "float":
            return f"(float)mp_obj_get_float({val})"
        if cc_type_str == "double":
            return f"(double)mp_obj_get_float({val})"
        if cc_type_str == "bool":
            return f"mp_obj_is_true({val}) ? 1 : 0"
        if cc_type_str.startswith("WasmRefID"):
            return f"mp_obj_int_get_uint64_checked({val})"
        if cc_type_str.startswith("Ptr"):
            return f"(int32_t)mp_obj_get_int({val})"
        if cc_type_str == "NullTerminatedString":
            return f"mp_obj_str_get_str({val})"
        return f"{PY_TO_WASM[value_type]}({val})"

    @staticmethod
    def wasm_to_py(value_type: ValueType, cc_type: GenericType, val: str) -> str:
        """Converts a Dergwasm value to a Python value, for return values."""
        cc_type_str = str(cc_type)
        if cc_type_str in ["int", "uint", "long", "ulong"]:
            return f"mp_obj_new_int_from_ll({val})"
        if cc_type_str in ["float", "double"]:
            return f"mp_obj_new_float({val})"
        if cc_type_str == "bool":
            return f"mp_obj_new_bool({val})"
        if cc_type_str.startswith("WasmRefID"):
            return f"mp_obj_new_int_from_ll({val})"
        if cc_type_str.startswith("Ptr"):
            return f"mp_obj_new_int_from_ll({val})"
        if cc_type_str == "NullTerminatedString":
            return f"mp_obj_new_null_terminated_str({val})"
        return f"{WASM_TO_PY[value_type]}({val})"

    def generate_header(self) -> None:
        with open("resonite_api.json", "r", encoding="UTF8") as f:
            data = json.load(f)

        generated_filename = output_dir() / "mp_resonite_api.h"
        with open(generated_filename, "w", encoding="UTF8") as f:
            f.write(HEADER_PREAMBLE)
            for item in data:
                f.write(f'extern mp_obj_t resonite__{item["Name"]}(')
                params = [f'mp_obj_t {param["Name"]}' for param in item["Parameters"]]
                f.write(", ".join(params))
                f.write(");\n")
            f.write(HEADER_POSTAMBLE)

    def generate_impl(self) -> None:
        with open("resonite_api.json", "r", encoding="UTF8") as f:
            data = json.load(f)

        for item in data:
            for p in item["Parameters"]:
                p["GenericType"] = GenericType.parse_generic_type(p["CSType"])
                p["ValueType"] = ValueType(p["Type"])

        generated_filename = output_dir() / "mp_resonite_api.c"
        with open(generated_filename, "w", encoding="UTF8") as f:
            f.write(IMPL_PREAMBLE)
            for item in data:
                params = item["Parameters"]
                in_params = [
                    f'mp_obj_t {p["Name"]}'
                    for p in params
                    if not p["Name"].startswith("out")
                ]
                f.write(
                    f'mp_obj_t resonite__{item["Name"]}({", ".join(in_params)}) {{\n'
                )

                # outs are always Ptrs.
                for p in params:
                    if not p["Name"].startswith("out"):
                        continue
                    c_type = self.wasm_to_c(p["GenericType"])
                    c_type = c_type[:-1]  # Remove the trailing '*'
                    f.write(f"  {c_type} {p['Name']};\n")
                f.write("\n")
                f.write(f'  resonite_error_t _err = {item["Name"]}(')

                call_params: list[str] = []
                for p in params:
                    converted = self.py_to_wasm(
                        p["ValueType"], p["GenericType"], p["Name"]
                    )
                    if p["Name"].startswith("out"):
                        converted = f"&{p['Name']}"
                    call_params.append(f"\n    {converted}")
                f.write(f'{", ".join(call_params)});\n')

                # The return value is always a tuple. The first element is
                # always the ResoniteError, and the remaining elements are
                # the out parameters.
                out_params: list[str] = []
                generic_type = GenericType.parse_generic_type("ResoniteError")
                converted = self.wasm_to_py(ValueType.I32, generic_type, "_err")
                out_params.append(f"\n    {converted}")

                for p in params:
                    if not p["Name"].startswith("out"):
                        continue
                    value_type = ValueType(p["Type"])
                    # This is, by definition, a Ptr to something.
                    generic_type = p["GenericType"].type_params[0]
                    converted = self.wasm_to_py(value_type, generic_type, p["Name"])
                    out_params.append(f"\n    {converted}")
                out_count = len(out_params)

                f.write(f"  mp_obj_t _outs[{out_count}] = {{")
                f.write(", ".join(out_params))
                f.write("};\n")
                f.write("\n")

                # Now we free anything we need to free.
                for p in params:
                    if not p["Name"].startswith("out"):
                        continue
                    generic_type = p["GenericType"].type_params[0]
                    if generic_type.base_type not in CC_TYPES_TO_FREE:
                        continue
                    f.write(f"  free({p['Name']});\n")
                f.write("\n")

                f.write(f"  return mp_obj_new_tuple({out_count}, _outs);\n")
                f.write("}\n\n")

    def main(self) -> int:
        self.generate_header()
        self.generate_impl()
        return 0
